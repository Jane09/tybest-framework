# 无锁
    没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功
# 偏向锁
    一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
    在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能
    偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。
# 轻量级锁
    当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。

# 重量级锁
    依赖操作系统Mutex Lock


# 公平锁 VS 非公平锁
    公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁
        优点：
            等待锁的线程不会饿死
        缺点：
            整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大
    非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁
        优点：
            减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程
        缺点：
            处于等待队列中的线程可能会饿死，或者等很久才会获得锁
    ReentrantLock默认使用非公平锁
    公平锁就是通过同步队列实现

# 可重入锁 VS 非可重入锁
    可重入锁：
        递归锁，指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞
        ReentrantLock和Synchronized都是重入的
        优点是避免死锁
        public class Widget {
            //内置锁是可以重入的
            public synchronized void doSomething() {
                System.out.println("方法1执行...");
                doOthers();
            }

            public synchronized void doOthers() {
                System.out.println("方法2执行...");
            }
        }

# 独享锁 VS 共享锁
    ReentrantLock和ReentrantReadWriteLock的源码来介绍独享锁和共享锁
    独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。
    JDK中的synchronized和JUC中Lock的实现类就是互斥锁。

    共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。
    独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享

    读读的过程共享，而读写、写读、写写的过程互斥

    ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁
